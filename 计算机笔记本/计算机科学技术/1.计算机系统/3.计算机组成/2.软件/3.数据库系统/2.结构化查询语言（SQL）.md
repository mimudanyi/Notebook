# 结构化查询语言（Structured Query Language）

## 一、数据定义语言（Data Definition Language，DDL）

|                   | 创建create | 删除drop | 修改alter |
| :---------------: | :--------: | :------: | :-------: |
|  数据库database   |     √      |    √     |     √     |
|   数据库表table   |     √      |    √     |     √     |
|     域domain      |     √      |    √     |     √     |
|     索引index     |     √      |    √     |           |
|     视图view      |     √      |    √     |           |
| 存储过程procedure |     √      |    √     |           |
|   触发器trigger   |     √      |    √     |           |
|    模式schema     |     √      |    √     |           |

```sql
-- 创建数据库
CREATE DATABASE 【数据库名称】;
ON [PRIMARY]
(   NAME=’数据文件的逻辑名称‘，
    FILENAME=‘ 文件的路径和文件名’，
    SIZE=文件的初始大小，
    MAXSIZE=文件的最大容量|UNLIMITED，
    F ILEGROWTH=文件的每次增长量） [，... n]
    FILEGROUP  文件组名
)
LOG ON
(   NAME='事务日志文件的逻辑名称'，
    FILENAME='文件的路径和文件名'，
    SIZE=文件的初始大小，
    MAXSIZE=文件的最大容量|UNL IMITED,
    F ILEGROWTH=文件的每次增长量） [，... n]
)

-- 删除数据库
DROP DATABASE 【数据库名】; 

-- 修改数据库
ALTER DATABASE 【数据库名】 MODIFY NAME=【新数据库名】 -- 修改数据库名
ALTER DATABASE 【数据库名】 ADD FILEGROUP 【文件组名】 -- （SQL Sever）新增文件组
ALTER DATABASE 【数据库名】 ADD FILE
(
    NAME='数据文件的逻辑名称',
    FILENAME='文件的路径和文件名',
    SIZE=文件的初始大小，
    MAXSIZE=文件的最大容量|UNL IMITED,
    FILEGROUP=文件的每次增长量
) -- （SQL Sever）新增辅助数据文件
ALTER DATABASE 【数据库名】
(
    NAME=‘数据文件的逻辑名称’，
    FILENAME=‘ 文件的路径和文件名‘，
    SIZE=文件的初始大小，
    MAXS IZE=文件的最大容量|UNL IMITED，
    FILEGROWTH=文件的每次增长量
) -- （SQL Sever）新增事物日志文件
ALTER DATABASE 【数据库名】 REMOVE FILEGROUP 【文件组名】; -- （SQL Sever）删除文件组名
ALTER DATABASE 【数据库名】 REMOVE FILE 【文件】; -- （SQL Sever）删除文件组名


-- 创建表
CREATE TABLE 【表名】(
    【列名1】 【列的数据类型】(长度) 【约束】 PRIMARY KEY, -- 设置主键,自然主键：auto_increment
    【列名2】 【列的数据类型】(长度) 【约束】 FOTEIGN KEY REFERENCES 【表名】(【列名】)， -- 设置外键
    【列名3】 【列的数据类型】(长度) 【约束】 DEFAULT 【默认值】, -- 指定默认值
    【列名4】 【列的数据类型】(长度) 【约束】,
    ...
    【列名n】 【列的数据类型】(长度) 【约束】，
    CONSTRAINT PK_列名 PRIMARY KEY(【列名1】，【列名2】，...) -- 设置主键
    UNIQUE(列名N,列名M,...) -- 表示括号中的所有列一起具有唯一性
);
CREATE TABLE 【表名1】 AS/省略 SELECT * FROM 【表名2】 WHERE 【条件】; -- 快照，对一个表进行快照，即复制一份当前表的数据到一个新表

--  删除表
DROP TABLE 【表名】;
DROP TABLE 【表名】 IF EXISTS 【表名】; -- 如果表存在就删除
TRUNCATE TABLE 【表名】; -- 删除巨大的表，表被截断，不可回滚，不可恢复

--  修改表
ALTER TABLE 【表名】 ADD CLOUMN 【列名】 【属性1】 【属性2】; -- 新增列
ALTER TABLE 【表名】 DROP COLUMN 【列名】; -- 删除列
ALTER TABLE 【表名】 CHANGE CLOUMN 【列名】 【修改后列名】 【属性1】 【属性2】; -- 修改列
-- 创建索引：关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。
ALTER TABLE 【表名】 ADD INDEX 【索引名】 (【列名】);
ALTER TABLE 【表名】 ADD INDEX 【索引名】 (【列名1】,【列名2】,【列名3】,...);
ALTER TABLE 【表名】 ADD UNIQUE INDEX 【索引名】 (【列名】); -- 唯一索引

-- 创建索引
CREATE INDEX 【索引名】 ON 【表名】(【列名】);

-- 删除索引
DROP INDEX 【索引名】ON 【表名】;

-- 创建视图
CREATE VIEW 【视图名】 AS 【列名】 ... FROM 【表名】;

-- 删除视图
DROP VIEW 【视图名】;
```

#### 1.1.1 表的分类

##### 永久表

##### 全局临时表

##### 局部临时表

#### 1.1.4 数据类型

##### 字符型数据

- 可变长度字符变量
- 固定长度字符变量

![字符型数据类型](Pictures\字符型数据类型.png)

##### 数字型数据

![数字型数据类型](Pictures\数字型数据类型.png)

![Number数据类型的具体含义](Pictures\Number数据类型的具体含义.png)

![货币数据类型](Pictures\货币数据类型.png)

##### 日期时间型数据

![日期数据类型](Pictures\日期数据类型.png)

##### 二进制数据

![二进制数据类型](Pictures\二进制数据类型.png)

##### 文本和图形数据

另外，SQL Server还提供了文本和图形数据类型，这类数据类型用于存储大量的字符或二进制数据，分别介绍如下。

- TEXT

  TEXT 数据类型用于存储大量文本数据，其容量理论上为1~2^23^-1(2 147 483 647）个字节，在实际应用时需要视硬盘的存储空间而定。

- NTEXT

  NTEXT 数据类型与TEXT类型相似。不同的是，NTEXT类型采用UNICODE标准字符集（Character Set)，因此其理论容量为2^30^-1 ( 1 073 741 823）个字节。

- IMAGE

  IMAGE数据类型用于存储大量的二进制数据（Binary Data )，理论容量为2^31^-1(2 147 483 647)个字节，存储数据的模式与TEXT数据类型相同。它通常用来存储图形等OLE（Object Linking and Embedding，对象连接和嵌入）对象。在输入数据时同BINARY 数据类型一样，我们必须在数据前加上字符“0x”作为二进制标识。

##### 自定义数据

除了使用系统提供的数据类型外，用户还可以用自定义的数据类型来定义表的列或声明变量。SQL提供的CREATE TYPE语句用于自定义数据类型，如下面语句将创建一个基于NUMERIC数据类型的用户自定义的类型。

#### 1.1.4 主键

- 主键共享

#### 1.1.5 约束

##### 主键约束（PRIMARY KEY）

既不能为NULL，也不能重复

##### 外键约束（FOREIGN KEY）

##### 非空约束（NOT NULL）

不能为NULL

##### 唯一约束（UNIQUE）

不能重复

##### 检查约束（CHECK）

Oracle才有

#### 1.1.6 存储引擎（存储方式）

##### MEMORY

##### MRG_MYUISAM

##### CSY

##### FESERATED

##### PERFORMANCE_SCHEMA

##### MyISAM

采用三张表组织一张表

- XXX.frm（存储格式的文件）
- XXX.MYD（存储表中数据的文件）
- XXX.MYI（存储表中索引的文件）

##### InnoDB

##### BLACKHOLE

##### ARCHIVE

#### 1.1.6 索引

模糊查询时，第一个是%会使索引失效

分类：

- 单一索引
- 复合索引
- 主键索引：主键自动添加索引
- 唯一索引：有UNIQUE约束的自动添加索引

#### 1.1.7 三范式（面试话语PS：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度）

构造数据库必须遵循一定的规则，在关系数据库中，这种规则就是范式。范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求，即满足不同的范式。目前关系数据库有6种范式:第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式（4NF）、第五范式（5NF）和第六范式（6NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以此类推。一般说来，数据库只需满足第三范式（3NF）就可以了。下面举例介绍第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。

##### 第一范式（1NF）

在任何关系数据库中,第一范式（1NF）是对关系模式的基本要求,不满足第一范式（1NF）的数据库就不是关系数据库。第一范式主要包括以下指导原则。

- 数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或重复的属性。如果出现重复的属性，数据库就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。
- 表的每一行只包含一个实例的信息。

简而言之，第一范式就是无重复的列。

##### 第二范式（2NF）：（口诀：多对多，三张表，关系表两个外键）

第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式(2NF)必须先满足第一范式(1NF)。

第二范式（2NF）要求数据库表中的每个实例或行必须是唯一的。为实现区分，我们通常需要为表加上一个列，以存储各个实例的唯一标识。如员工信息表中加上了员工编号EMP_ID 列，每个员工的编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。

第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分，我们通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。

##### 第三范式（3NF）：（口诀：一对多，两张表，多的表加外键）

满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其他表中包含的非主关键字信息。例如一个部门信息表，其中每个部门有部门编号DEPT_ID、部门名称、部门简介等信息。那么我们在员工信息表中列出部门编号DEPT_ID后，就不能再将部门名称、部门简介等与部门有关的信息加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。

##  二、数据查询语言（Data Query Language，DQL）

![查询语句分类](Pictures\查询语句分类.png)

![连接查询饿分类](Pictures\连接查询的分类.png)

![运算符](Pictures\运算符.png)

#### 1.2.1 单表查询

```sql
-- 查询所有数据
SELECT * FROM 【数据库表名】;

-- 条件查询
-- 常用的条件表达式：=、>、>=、<、<=、<>或!=、LIKE
SELECT * FROM 【表名】 WHERE 【条件表达式】;
SELECT * FROM 【表名】 WHERE 【条件表达式1】 AND 【条件表达式2】; -- 表示满足条件1并且满足条件2
SELECT * FROM 【表名】 WHERE 【条件表达式1】 OR 【条件表达式2】; -- 表示满足条件1或者满足条件2
SELECT * FROM 【表名】 WHERE 【列名】 IN (【条件表达式1】,【条件表达式2】); -- 表示满足条件1或者满足条件2
SELECT * FROM 【表名】 WHERE 【列名】 NOT 【条件表达式】; -- 表示不符合该条件的记录
SELECT * FROM 【表名】 WHERE 【列名】 NOT IN (【条件表达式1】,【条件表达式2】); -- 表示不满足条件1或者满足条件2
SELECT * FROM 【表名】 WHERE 【列名】 BETWEEN 【值1】 AND 【值2】; -- 查询字段数值为值1和值2之间的数据
SELECT * FROM 【表名】 WHERE 【列名】 IS NULL; -- 查询字段为空的数据
SELECT * FROM 【表名】 WHERE 【列名】 IS NOT NULL; -- 查询字段不为空的数据
SELECT * FROM 【表名】 WHERE 【列名】 LIKE 【值】 -- 模糊查询，查询像只的数据，其中_表示单个字符，%表示多个字符

-- 投影查询
SELECT 【列1】，【列2】，【列3】 as/空格 【查询后的列名】 FROM 【数据库表名】 ...;

-- 排序查询
SELECT 【列名1】，【列名2】，【列名3】,... FROM 【表名】 ORDER BY 【列名】，【列名】...; -- 顺序
SELECT 【列名1】，【列名2】，【列名3】,... FROM 【表名】 ORDER BY 【列名】 ASC，【列名】...; -- 顺序
SELECT 【列名1】，【列名2】，【列名3】,... FROM 【表名】 ORDER BY 【列名】 DESC，【列名】...; -- 倒序
SELECT 【列名1】，【列名2】，【列名3】,... FROM 【表名】 ORDER BY 【数字】; -- 根据第几列排序

-- 强制使用指定索引
SELECT * FROM 【表名】 FORCE INDEX (【索引名】) WHERE 【条件表达式】 ORDER BY 【列名】 DESC;

-- 分页查询
SELECT * FROM 【表名】 ORDER BY 【列名】 LIMIT 【每页几行】 OFFSET 【从几行开始】; -- 在MySQL中可以使用
SELECT * FROM 【表名】 ORDER BY 【列名】 LIMIT 【从几行开始】【每页几行】; -- 在MySQL中可以使用 

-- 聚合/分组函数查询
/* 	如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL
	聚合/分组函数不可直接使用在WHERE中
	聚合/分组函数会自动排除 NULL
	当一条语句中有 GROUP BY 的话，SELECT 后面只能跟分组函数和参与分组的字段*/
SELECT COUNT(*) FROM 【数据库表名】; --查询数据库表一共有多少行，查询的结果仍然是一个二维表
SELECT COUNT(【列名】) FROM 【表名】; -- 查询算某一列一共有多少行
SELECT SUM(【列名】) FROM 【表名】; -- 计算某一列的合计值，该列必须为数值类型
SELECT AVG(【列名】) FROM 【表名】; -- 计算某一列的合计值，该列必须为数值类型
SELECT MAX(【列名】) FROM 【表名】; -- 计算某一列的最大值
SELECT MIN(【列名】) FROM 【表名】; -- 计算某一列的最小值
SELECT IFNULL(【列名】，【处理后的数据】) FROM 【表名】;

-- 分组查询
SELECT COUNT(*) num FROM 【数据库表名】 GROUP BY 【列名】;
SELECT COUNT(*) num FROM 【数据库表名】 GROUP BY 【列名1】，【列名2】,...; --  联合分组

-- 去重查询
SELECT DISTINCT 【列名】 FROM 【表名】;

-- 设置别名
SELECT
    s.id sid,
    s.name,
    s.gender,
    s.score,
    c.id cid,
    c.name cname
FROM students s, classes c;
```

#### 1.2.2 多表查询

```sql
-- 多表查询
-- 会产生笛卡尔积现象
SELECT * FROM <表1> <表2>

-- 连接查询
-- 1、内连接查询（等值查询）
-- 先确定主表，仍然使用FROM <表1>的语法；
-- 再确定需要连接的表，使用INNER JOIN <表2>的语法；
-- 然后确定连接条件，使用ON <条件...>，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；
-- 可选：加上WHERE子句、ORDER BY等子句。
如：
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
INNER JOIN classes c
ON s.class_id = c.id;
-- 2、外连接查询
如：
SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;
-- 3、全连接查询
```

#### 1.2.3 子查询

SELECT 语句中可以嵌套 SELECT 语句，被嵌套的 SELECT 语句是子查询。

可以出现在以下地方：

```sql
SELECT
  ...(SELECT)...
FROM
  ...(SELECT)...
WHERE 
  ...(SELECT)...
```

#### 1.2.4 集合查询

```sql
SELECT * FROM 【表名】 WHERE 【条件表达式】 
UNION
SELECT * FROM 【表名】 WHERE 【条件表达式】;
```

#### 1.2.5 DQL语句的执行顺序

```sql
SELECT                  5
  ...(SELECT)...
FROM                    1
  ...(SELECT)...
(INNER/OUTER) JOIN 
  ...(SELECT)...
ON 
  ...
WHERE                   2
  ...(SELECT)...
GROUP BY                3
  ...
HAVING                  4
  ...
ORDER BY                6
  ...
LIMIT                   7
  ...

UNION
  ...
```

## 三、数据操控语言（Data Manipulation Language，DML）

```sql
-- 向数据库表添加新数据行。
INSERT INTO 【表名】 (【字段1】, 【字段2】, ...) VALUES (【值1】, 【值2】, ...)，(【值a】, 【值b】, ...)...;
INSERT INTO 【表名】 VALUES (【值1】, 【值2】, ...)，(【值a】, 【值b】, ...)...; -- 必须插入全部字段

-- 向数据库表添加新数据行，先判断是否存在记录，如果记录已经存在，就先删除原记录，再插入新记录。（插入或替换）
REPLACE INTO 【表名】 (【字段1】,【字段2】,...) VALUES (【值1】, 【值2】, ...)，(【值a】, 【值b】, ...)...;

-- 插入一条新记录，但如果记录已经存在，就更新该记录（插入或替换）
INSERT INTO 【表名】 (【字段1】,【字段2】,...) VALUES (【值1】, 【值2】, ...) ON DUPLICATE KEY UPDATE 字段=值, 字段=值, 字段=值;

-- 插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略（插入或忽略）
INSERT IGNORE INTO 【表名】 (【字段1】,【字段2】,...) VALUES (【值a】, 【值b】, ...);

-- 插入查询结果
INSERT INTO 【表名1】 (【字段1】, 【字段2】, ...) SELECT 【字段7】, 【字段8】, ... FROM 【表名2】 GROUP BY 【列名】;

-- 从数据库表中删除数据行。
DELETE FROM <表名> WHERE ...;

-- 更新数据库表中的数据。
UPDATE 【表名】 SET 【字段1】=【值1/表达式】, 【字段2】=【值2/表达式】, ... WHERE ...;
```

## 四、数据控制语言（Data Control Language，DCL）

```sql
-- 新建用户
CREATE UESR 【用户名】 IDENTIFIED BY'【密码】'; -- 登录后只能查看当前数据库

-- 授权用户访问权限。
grant 

-- 拒绝用户访问。
deny 

-- 解除用户访问权限。
revoke 

-- 导出
-- 导出整个数据库（不是SQL语句，是在Windows的哆嗦命令窗口执行）
mysqldump 【数据库名】>【位置+导出文件名.sql】 -u【用户名】 -r【密码】
-- 导出指定库下的指定表（不是SQL语句，是在Windows的哆嗦命令窗口执行）
mysqldump 【数据库名】 【表名】>【位置+导出文件名.sql】 -u【用户名】 -r【密码】

-- 导入
进入mysql后，执行：source 【位置+导出文件名.sql】
```

![image-20210310171023918](C:\Users\23198\AppData\Roaming\Typora\typora-user-images\image-20210310171023918.png)

![image-20210310171229831](C:\Users\23198\AppData\Roaming\Typora\typora-user-images\image-20210310171229831.png)

![image-20210310171305457](C:\Users\23198\AppData\Roaming\Typora\typora-user-images\image-20210310171305457.png)

![image-20210310171343134](C:\Users\23198\AppData\Roaming\Typora\typora-user-images\image-20210310171343134.png)

![image-20210310171401508](C:\Users\23198\AppData\Roaming\Typora\typora-user-images\image-20210310171401508.png)

## 五、事务控制语言（Transaction Control Language，TCL）

```sql
/*
对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。
要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务
*/
BEGIN; --开启一个事物
SQL语句;
COMMIT; -- 提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。

BEGIN;
SQL语句;
ROLLBACK; -- 些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败：

开启事务：Start Transaction
事务结束：End Transaction
提交事务：Commit Transaction
回滚事务：Rollback Transaction
```

#### 1.5.1 事务

事务控制语言只会对DML语言进行操作。

事务四大特性：ACID

- 原子性：事务是最小的工作单元，不可再分。
- 一致性：事务必须保证多条DML语句同时成功或者失败。
- 持久性：最终数据必须持久到硬盘文件中，事务才算成功的结束。
- 隔离性：事务A与事务B之间具有隔离。

##### 事务隔离级别

对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。

SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：

| Isolation Level                   | 脏读（Dirty Read） | 不可重复读（Non Repeatable Read） | 幻读（Phantom Read） |
| :-------------------------------- | :----------------: | :-------------------------------: | :------------------: |
| Read Uncommitted（读未提交）      |        Yes         |                Yes                |         Yes          |
| Read Committed（读已提交）        |         -          |                Yes                |         Yes          |
| Repeatable Read（可重复读）       |         -          |                 -                 |         Yes          |
| Serializable（序列化读/串行化读） |         -          |                 -                 |          -           |

**脏读**：Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据。

**不可重复读**：在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。

**幻读**：在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

```sql
-- 设置隔离级别
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。

-- 查看事物的全局级别
SELECT @@GLOBAL.TX_ISOLATION;
```

oracle数据库默认的隔离级别是:读已提交。

mysql数据库默认的隔离级别是:可重复读。

## 六、指针控制语言（Cursor Control Language，CCL）

```sql

```

## 七、程序化语言

```sql
declare -- 为查询设定游标。
explan -- 为查询描述数据访问计划。
open -- 检索查询结果打开一个游标。
fetch -- 检索一行查询结果。
close -- 关闭游标。
prepare -- 为动态执行准备SQL。
describe -- 描述准备好的查询。
```

## 八、其他

```sql
-- 切换到一个数据库
USE 【数据库名】;

-- 查看所有数据库
SHOW DATABASES;

-- 查看当前数据库的所有表
SHOW TABLES;

-- 查看其它数据库的表
SHOW TABLES FORM 【数据库名称】;

-- 查看创建表的SQL语句
SHOW CREATE TABLE 【表名】;

-- 查看MySQL支持的存储引擎
SHOW ENGINES \G

-- 查询当前使用的数据库
SELECT DATABASE();

-- 查看MySQL的版本号
SELECT VERSION();

-- 查看表的结构
DESC 【表名】;

-- （MySQL命令）运行SQL脚本
SOURCE 【路径+文件名.sql】

-- （MySQL命令）连接MySQL Server
mysql -h 【地址】 -u root -p

-- 终止一条正在编写的语句
\c

-- 查看语句执行计划
EXPLAIN 加SQL语句

-- 退出MySQL
exit、\q、quit
```
